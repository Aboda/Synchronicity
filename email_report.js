
/*
  This section belongs to a calculation troubleshooting email that is being used to fine tune the output.
*/
function send_report_as_email(){

    let last_event_report = fetch_user_property("last_report")
    let message = `Hi there, this email was generated by the "SEND REPORT" button on the Synchronicity Workspace Add On for Google Calendar.
    
    It corresponds to execution no. ${last_event_report.load_event} by the google email account ${last_event_report.email} with the availability output:
    
    ${last_event_report.output}
  
    Below you can find the information evaluated from your google calendar to produce this result:
  
    Selection of blocking calendars:
    ${blocking_calendars_printer(last_event_report.blocking_calendars)}
  
    Available weekdays sougth:
    ${print_available_weekdays(last_event_report)}
  
    Requested Date Range: ${last_event_report.date_frame.start + " to " + last_event_report.date_frame.end}, (${last_event_report.number_of_days} of ${last_event_report.date_range} days evaluated)
    
    Date/s evaluated:
    ${print_array_with_simple_breaks(last_event_report.date_array)}
   
    Browser Offset
    ${"UTC "+local_utc_offset()}
  
    Script Timezone
    ${last_event_report.script_user_timezone+" UTC "+last_event_report.script_user_offset}
  
    Offset between browser and script timezone
    ${last_event_report.script_offset_distance}
  
    
    Target Timezone
    ${last_event_report.target_timezone+" UTC "+last_event_report.target_offset}
  
    Offset between browser and target timezone
    ${last_event_report.offset_distance}
  
    Per Day Evaluation Table:
    ${per_day_evaluation_table(last_event_report)}
  
    Below you will find the memory of the application at the time of this event for additional troubleshooting purposes.
    ${reduced_settings(last_event_report)}`
    
    MailApp.sendEmail(last_event_report.email, "Synchronicity report no. "+last_event_report.load_event, message)
  
    return card_quick_feedback("Synchronicity report sent to operating email address")
  }
  
  function text_output_list_content(cal_names){
    if (Object.keys(cal_names).length == 0){
      return "none"
    }
    let reply = ""
    for (let cal_id in cal_names) {
      cal_name = cal_names[cal_id]
      reply = reply + "\n" + cal_name
    }
    return reply
  }
  
  function per_day_evaluation_table(ler){
    let prog = 0
    let t = ""
    for (evaluated_date of ler.date_array) {
      t = t + "\n\nEvaluated Date Offset to script timezone 0 hours:" + new Date(evaluated_date).toJSON()
      t = t + "\nEvaluated Available hours range " + new Date(ler.specific_timeframe_array[prog][0]).toJSON() +" "+ new Date(ler.specific_timeframe_array[prog][1]).toJSON()
      t = t + "\n" + available_time(ler.slotted_timeframe_array[prog])
      t = t + "\n"+ date_events(ler,prog)
      prog ++
    }
    return t
  }
  
  function available_time(boolean_array){
    let t = ""
    let hour = 0
    for (values of boolean_array){
      if (hour % 60 == 0){
        t = t + "\n"
      }
      if(values){
        t = t + "a"
      }else{
        t = t + "o"
      }
      hour ++
    }
    return t
  }
  
  function date_events(ler,prog){
    evaluated_date = new Date(evaluated_date)
    let t = ""
    for (let event_id in ler.events_from_blocking_calendars){
      let event = ler.events_from_blocking_calendars[event_id]
      let event_start = new Date(event.startTime).getTime()
      let event_end = new Date(event.endTime).getTime()
      let go = false
      if (event_start > ler.specific_timeframe_array[prog][0] &&
        event_start < ler.specific_timeframe_array[prog][1]){
          go = true
      }
      if (event_end > ler.specific_timeframe_array[prog][0] &&
        event_end < ler.specific_timeframe_array[prog][1]){
          go = true
      }
      if (go){
        t = t + "\n FROM:" + new Date(event.startTime).toJSON() + " TO: " + new Date(event.endTime).toJSON()  + "  CAL: " +  event.calendar + "  TITLE: " + event.title + "  STATUS: " + event.status + "  BLOCKING: " + ler.guest_status[event.status]
      }
    }
    return t
  }
  
  function reduced_settings(ler){
    delete ler.slotted_timeframe_array
    return JSON.stringify(ler,null,2)
  }

  function blocking_calendars_printer(blocking_cals){
    let string = ""
    for (let cal_id in blocking_cals) {
      let cal = blocking_cals[cal_id]
      string = string + "\nCalendar: "+cal.name+" Blocking: "+cal.blocking
    }
    return string
  }
  
  function print_available_weekdays(ler){
    let t = ""
    for (let day of ler.weekdays){
      if (ler.dotw[day]){
        t = t + "\n"+day
      }
    }  
    return t
  }
  
  function print_array_with_simple_breaks(array){
    let t = ""
    for (let elements of array) {
      t = t+ "\n"+elements
    }
    return t
  }