/*
  This serves the card that is loaded at launch of a Workspace Add On, cards are
  the preferred method for interaction with the user for this type of deployment

  Cards cannot be modified once printed, an entire new card needs to be built to
  perform any interface update. This is again, part of the encouraged strategy.

  Cards abstract multiple tools and features requiring consideration in the dev
  process to attain proper integration and desired functionality.

  Cards have special capabilities like "contextual" menus, these are integrated
  to the google product user experience based on the context. For example, in
  our case, we should be able to create a small card that reacts to the user
  selecting an event on his google calendar interface* 
  
  While currently calendar cards are not available on mobile applications, there
  is a strong implication that they will be. 
  
  Additionally a consideration is that this code is run in and as apps script
  itself, meaning that a) it is single threaded synchronous and b) it can run
  apps scripts resources without google.script.run/asynchronous methods
*/

function build_card_main(user_settings){
  return CardService.newCardBuilder()
    .setName("Main")
    .addSection(build_widget_output_main(user_settings))
    .build();  
}

/*
  Main output and interface
*/
function build_widget_output_main(user_settings){
  return CardService.newCardSection()
  .setHeader("Availability")
  .addWidget(build_main_output(user_settings))
  .addWidget(
    CardService.newButtonSet()
      .addButton(build_item_button_refresh())
      .addButton(build_item_button_settings())
      //.addButton(build_item_button_display())
      //.addButton(build_item_button_delete())
      .addButton(build_item_button_send_output_report())
  );
}



/*
  This is the text buttons creation
*/

function build_item_button_refresh(){
  return cards_text_button("Refresh","interface_action_refresh_output")
}

function build_item_button_settings(){
  return cards_text_button("Settings","build_card_settings")
}

/*
  These are dev buttons
*/

function build_item_button_delete(){
  return cards_text_button("delete mem","delete_user_settings")
}

function build_item_button_display(){
  return cards_text_button("show mem","show_user_memory")
}

function build_item_button_send_output_report(){
  return cards_text_button("send report","send_report_as_email")
}

/*
  Here the actions enabled by each button
*/
function interface_action_refresh_output(e) {
  /*
    This seems easily doable as it will only mean a restart of the cycle
  */ 
  return build_card_main(state_fetch_or_create_user(e))
}

function send_report_as_email(){

  let last_event_report = fetch_user_property("last_report")
  let message = `Hi there, this email was generated by the "SEND REPORT" button on the Synchronicity Workspace Add On for Google Calendar.
  
  It corresponds to execution no. ${last_event_report.load_event} by the google email account ${last_event_report.email} with the availability output:
  
  ${last_event_report.output}

  Below you can find the information evaluated from your google calendar to produce this result:

  Considered / Visible Calendars:
  ${text_output_list_content(last_event_report.available_calendars.visible)}

  Ignored / Hidden Calendars:
  ${text_output_list_content(last_event_report.available_calendars.hidden)}

  Requested Date Range: ${new Date(last_event_report.date_frame.start).toLocaleDateString()+ " to " +new Date(last_event_report.date_frame.end).toLocaleDateString()}, (${last_event_report.number_of_days} days)

  Per Day Evaluation Table:
  ${per_day_evaluation_table(last_event_report)}

  Below you will find the memory of the application at the time of this event for additional troubleshooting purposes.
  ${JSON.stringify(last_event_report,null,2)}`
  MailApp.sendEmail(last_event_report.email, "Synchronicity report no. "+last_event_report.load_event, message)

  return card_quick_feedback("Synchronicity report sent to operating email address")
}

function text_output_list_content(cal_names){
  if (Object.keys(cal_names).length == 0){
    return "none"
  }
  let reply = ""
  for (let cal_id in cal_names) {
    cal_name = cal_names[cal_id]
    reply = reply + "\n" + cal_name
  }
  return reply
}

function per_day_evaluation_table(ler){
  let prog = 0
  let t = ""
  for (evaluated_date of ler.date_array) {
    t = t + "\n\n" + new Date(evaluated_date).toLocaleDateString()
    t = t + "\n" + new Date(ler.specific_timeframe_array[prog][0]).toLocaleTimeString() +" "+ new Date(ler.specific_timeframe_array[prog][1]).toLocaleTimeString()
    t = t + "\n" + available_time(ler.slotted_timeframe_array[prog])
    t = t + "\n"+ date_events(ler,evaluated_date)
    prog ++
  }
  return t
}

function available_time(boolean_array){
  let t = ""
  for (values of boolean_array){
    if(values){
      t = t + "o"
    }else{
      t = t + "x"
    }
  }
  return t
}

function date_events(ler,evaluated_date){
  evaluated_date = new Date(evaluated_date)
  let t = ""
  for (let event_id in ler.events_from_visible_calendars){
    let event = ler.events_from_visible_calendars[event_id]
    let event_start = new Date(event.startTime)
    let compare_ev_date = evaluated_date.getFullYear() +"/"+ evaluated_date.getMonth() +"/"+ evaluated_date.getDate()
    let compare_es_date = event_start.getFullYear() +"/"+ event_start.getMonth() +"/"+ event_start.getDate()
    if (compare_ev_date == compare_es_date){
      t = t + "\n" + new Date(event.startTime).toLocaleTimeString() + " to " + new Date(event.endTime).toLocaleTimeString()  + " cal: " +  event.calendar + " title: " + event.title + " status: " + event.status
    }
  }
  return t
}